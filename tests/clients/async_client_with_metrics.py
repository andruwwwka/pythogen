# ==============================================================================
#
# Client (HTTP-client)
#
# This file was generated by a code generator.
# Don't make changes to it manually.
#
# ==============================================================================

# jinja2: lstrip_blocks: "True"
# mypy: ignore-errors

from __future__ import annotations

import datetime
import logging
from dataclasses import dataclass
from enum import Enum
from enum import IntEnum
from typing import IO
from typing import Any
from typing import Mapping
from typing import Protocol
from typing import Sequence
from typing import Union
from typing import get_type_hints

import httpx
from httpx import Timeout
from prometheus_client import Counter
from prometheus_client import Histogram
from pydantic import BaseModel
from pydantic import ConfigDict
from pydantic import Field
from pydantic import FieldValidationInfo
from pydantic import HttpUrl
from pydantic import field_validator


# backward compatibility for httpx<0.18.2
try:
    DEFAULT_AUTH = httpx.USE_CLIENT_DEFAULT
except AttributeError:
    DEFAULT_AUTH = None


class MetricsIntegration(Protocol):
    def __init__(
        self,
        client_response_time_histogram: Histogram | None = None,
        client_non_http_errors_counter: Counter | None = None,
        shadow_path: bool = True,
    ):
        self._client_response_time_histogram = client_response_time_histogram
        self._client_non_http_errors_counter = client_non_http_errors_counter
        self.shadow_path = shadow_path

    def on_request_error(
        self, client_name: str, error: Exception, http_method: str, http_target: str
    ) -> None:
        ...

    def on_request_success(
        self, client_name: str, response, http_method: str, http_target: str
    ) -> None:
        ...


class DefaultMetricsIntegration:
    def on_request_error(
        self, client_name: str, error: Exception, http_method: str, http_target: str
    ) -> None:
        self._client_non_http_errors_counter.labels(
            client_name=client_name,
            http_method=http_method,
            http_target=http_target,
            exception=error.__class__.__name__,
        ).inc(1)
        raise error

    def on_request_success(
        self, client_name: str, response, http_method: str, http_target: str
    ) -> None:
        self._client_response_time_histogram.labels(
            client_name=client_name,
            http_method=http_method,
            http_target=http_target,
            http_status_code=response.status_code,
        ).observe(response.elapsed.total_seconds())


@dataclass
class RequestBox:
    client_name: str
    method: str
    url: str
    params: dict[str, Any]
    headers: dict[str, Any]
    content: Any


@dataclass
class ResponseBox:
    status_code: int


class LogsIntegration(Protocol):
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        ...

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        ...

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        ...


class DefaultLogsIntegration:
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {"props": {"data": kwargs}}

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        msg = f"request error"
        msg += f" | client={req.client_name}"
        msg += f" | method={req.method}"
        msg += f" | url={req.url}"
        msg += f" | params={req.params}"
        msg += f" | content={req.content}"
        msg += f" | headers={req.headers}"

        level = self.get_log_error_level(req, resp)

        logging.log(
            level,
            msg,
            extra=self.log_extra(
                client=req.client_name,
                method=req.method,
                content=req.content,
                url=req.url,
                params=req.params,
            ),
        )

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        if resp.status_code >= 500:
            return logging.ERROR
        elif resp.status_code >= 400:
            return logging.WARNING
        elif resp.status_code >= 300:
            return logging.INFO
        elif resp.status_code >= 200:
            return logging.INFO
        else:
            return logging.INFO


FileContent = Union[IO[str], IO[bytes], str, bytes]
FileTypes = Union[
    # file (or text)
    FileContent,
    # (filename, file (or text))
    tuple[str | None, FileContent],
    # (filename, file (or text), content_type)
    tuple[str | None, FileContent, str | None],
]


class RequiredHeaders(Exception):
    ...


class StringEnum(str, Enum):
    """
    StringEnum
    """

    FIRST = "first"
    SECOND = "second"

    def __str__(self) -> Any:
        return self.value


class IntegerEnum(IntEnum):
    """
    IntegerEnum
    """

    _1 = 1
    _2 = 2
    _3 = 3
    _4 = 4
    _5 = 5
    _6 = 6


class EmptyBody(BaseModel):
    status_code: int
    text: str


class BaseObjectResp(BaseModel):
    string_data: str

    @field_validator("string_data", mode="before")
    def check(cls, v: str, info: FieldValidationInfo) -> str:
        type_hints = get_type_hints(cls)
        string_data_values: tuple[str] = type_hints["string_data"].__dict__["__args__"]

        if v not in string_data_values:
            raise ValueError(f"invalid string_data for {cls}")

        return v


class AllOfRefObj(BaseModel):
    """
    All Of
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    id: str | None = None
    data: int | None = None


class GetBinaryResponse200(BaseModel):
    """
    None
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    content: bytes | None = None


class GetTextAsIntegerResponse200(BaseModel):
    """
    None
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    text: int | None = None


class GetTextResponse200(BaseModel):
    """
    None
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    text: str | None = None


class GetListObjectsResponse200(BaseModel):
    """
    None
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )


class RewardsListItem(BaseModel):
    """
    None
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # required ---
    pricePlanCode: str
    quantity: float


class GetObjectWithInlineArrayResponse200(BaseModel):
    """
    None
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    rewards: list[RewardsListItem] | None = None


class GetObjectWithInlineArrayResponse200Item(BaseModel):
    """
    None
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # required ---
    pricePlanCode: str
    quantity: float


class TierObj(BaseModel):
    """
    None
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    code: str | None = None
    name: str | None = None
    priority: int | None = None


class GetObjectNoRefSchemaResponse200(BaseModel):
    """
    GetObjectResp
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    string_data: str | None = Field(
        None, description="String Data. [__discriminator__(BaseObjectResp.string_data)]"
    )
    integer_data: int | None = None
    array_data: list[str] | None = None
    boolean_data: bool | None = None


class SafetyKeyForTesting(BaseModel):
    """
    model for testing safety key
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    for_: str | None = Field(
        None, description='reserved word, expecting "for_"', alias="for"
    )
    class_: str | None = Field(
        None, description='reserved word, expecting "class_"', alias="class"
    )
    with_dot_and_hyphens: int | None = Field(
        None,
        description='invalid identifier, expecting "with_dot_and_hyphens"',
        alias="33with.dot-and-hyphens&*",
    )
    old_feature_priority: int | None = Field(
        None,
        description='__safety_key__(old_feature_priority) invalid identifier, expecting "old_feature_priority"',
        alias="34with.dot-and-hyphens&*",
    )


class UnknownError(BaseModel):
    """
    UnknownError
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    code: str | None = None


class DeleteObjectResp(BaseModel):
    """
    DeleteObjectResp
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    status: str | None = None


class PutObjectResp(BaseModel):
    """
    PutObjectResp
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    status: str | None = None


class PatchObjectResp(BaseModel):
    """
    PatchObjectResp
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    status: str | None = None


class PostObjectResp(BaseModel):
    """
    PostObjectResp
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    status: str | None = None


class PostFile(BaseModel):
    """
    PostFile
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # required ---
    text: str


class PutObjectData(BaseModel):
    """
    PutObjectData
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # required ---
    id: str
    data: int


class PatchObjectData(BaseModel):
    """
    PatchObjectData
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # required ---
    id: str
    data: int


class PostObjectData(BaseModel):
    """
    PostObjectData
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # required ---
    string_data: str
    integer_data: int
    array_data: list[str]
    boolean_data: bool
    event_data: dict = Field(
        description="__safety_key__(event_data)", alias="event-data"
    )

    # optional ---
    optional_anyof_string_data: str | None = None
    date_attr: datetime.date | None = None
    datetime_attr: datetime.datetime | None = None
    url: HttpUrl | None = None
    int_enum: IntegerEnum | None = Field(None, description="An enumeration.")
    str_enum: StringEnum | None = Field(None, description="An enumeration.")
    int_enum_or_null: IntegerEnum | None = None


class Dog(BaseModel):
    """
    Dog
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    name: str | None = None


class Cat(BaseModel):
    """
    Cat
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    name: str | None = None


class GetObjectResp(BaseModel):
    """
    GetObjectResp
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    string_data: str | None = Field(
        None, description="String Data. [__discriminator__(BaseObjectResp.string_data)]"
    )
    integer_data: int | None = None
    array_data: list[str] | None = None
    boolean_data: bool | None = None
    tier: TierObj | None = None
    anyOfChild: GetObjectResp | Cat | None = None
    child: GetObjectResp | None = None
    childs: list[GetObjectResp] | None = None
    animal: Cat | Dog | None = None


class Data(BaseModel):
    """
    Data
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    id: str | None = None
    data: int | None = None


class AllOfResp(BaseModel):
    """
    All Of Resp
    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    # optional ---
    all_of: AllOfRefObj | None = None


class BasicAuth(BaseModel):
    username: str
    password: str


class Client:
    def __init__(
        self,
        base_url: str,
        timeout: int = 5,
        client_name: str = "",
        client: httpx.AsyncClient | None = None,
        headers: dict[str, str] | None = None,
        metrics_integration: MetricsIntegration | None = None,
        logs_integration: LogsIntegration | None = DefaultLogsIntegration(),
    ):
        self.client = client or httpx.AsyncClient(timeout=Timeout(timeout))
        self.base_url = base_url
        self.headers = headers or {}
        self.metrics_integration = metrics_integration
        self.logs_integration = logs_integration
        self.client_name = client_name

    async def get_object_no_ref_schema(
        self,
        object_id: str,
        from_: str,
        return_error: str | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetObjectNoRefSchemaResponse200 | None:
        url = self._get_url(f"/objects/no-ref-schema/{object_id}")

        params = {
            "from": from_,
        }
        if return_error is not None:
            params["return_error"] = return_error

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name,
                        exc,
                        "get",
                        "/objects/no-ref-schema/:object_id",
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name,
                        exc,
                        "get",
                        f"/objects/no-ref-schema/{object_id}",
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name,
                    response,
                    "get",
                    "/objects/no-ref-schema/:object_id",
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name,
                    response,
                    "get",
                    f"/objects/no-ref-schema/{object_id}",
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetObjectNoRefSchemaResponse200.model_validate(response.json())

    async def get_object(
        self,
        object_id: str,
        from_: str,
        return_error: str | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetObjectResp | UnknownError:
        url = self._get_url(f"/objects/{object_id}")

        params = {
            "from": from_,
        }
        if return_error is not None:
            params["return_error"] = return_error

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/objects/:object_id"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/objects/{object_id}"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/objects/:object_id"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/objects/{object_id}"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetObjectResp.model_validate(response.json())

        if response.status_code == 500:
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return UnknownError.model_validate(response.json())

    async def get_object_with_inline_array(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> list[GetObjectWithInlineArrayResponse200Item] | None:
        url = self._get_url(f"/object-with-array-response")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/object-with-array-response"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/object-with-array-response"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/object-with-array-response"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/object-with-array-response"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return [
                GetObjectWithInlineArrayResponse200Item.model_validate(item)
                for item in response.json()
            ]

    async def get_object_with_inline_array(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetObjectWithInlineArrayResponse200 | None:
        url = self._get_url(f"/object-with-inline-array")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/object-with-inline-array"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/object-with-inline-array"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/object-with-inline-array"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/object-with-inline-array"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetObjectWithInlineArrayResponse200.model_validate(response.json())

    async def get_list_objects(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> list[GetObjectResp] | None:
        url = self._get_url(f"/objects")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/objects"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/objects"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/objects"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/objects"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return [GetObjectResp.model_validate(item) for item in response.json()]

    async def get_text(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetTextResponse200 | None:
        url = self._get_url(f"/text")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/text"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/text"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/text"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/text"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetTextResponse200(text=response.text)

    async def get_text_as_integer(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetTextAsIntegerResponse200 | None:
        url = self._get_url(f"/text_as_integer")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/text_as_integer"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/text_as_integer"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/text_as_integer"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/text_as_integer"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetTextAsIntegerResponse200(text=response.text)

    async def get_empty(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> EmptyBody | None:
        url = self._get_url(f"/empty")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/empty"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/empty"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/empty"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/empty"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return EmptyBody(status_code=response.status_code, text=response.text)

    async def get_binary(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetBinaryResponse200 | None:
        url = self._get_url(f"/binary")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/binary"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/binary"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/binary"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/binary"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetBinaryResponse200(content=response.content)

    async def get_allof(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> AllOfResp | None:
        url = self._get_url(f"/allof")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/allof"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/allof"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/allof"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/allof"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return AllOfResp.model_validate(response.json())

    async def get_object_slow(
        self,
        object_id: str,
        return_error: str | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetObjectResp | UnknownError:
        url = self._get_url(f"/slow/objects/{object_id}")

        params = {}
        if return_error is not None:
            params["return_error"] = return_error

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", "/slow/objects/:object_id"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "get", f"/slow/objects/{object_id}"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", "/slow/objects/:object_id"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "get", f"/slow/objects/{object_id}"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetObjectResp.model_validate(response.json())

        if response.status_code == 500:
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return UnknownError.model_validate(response.json())

    async def post_object_without_body(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/post-without-body")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "post",
                url,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", "/post-without-body"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", f"/post-without-body"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", "/post-without-body"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", f"/post-without-body"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def post_object(
        self,
        body: PostObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/objects")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "post",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", "/objects"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", f"/objects"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", "/objects"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", f"/objects"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def post_form_object(
        self,
        body: PostObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/objects-form-data")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        headers_.update({"Content-Type": "application/x-www-form-urlencoded"})
        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "post",
                url,
                data=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", "/objects-form-data"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", f"/objects-form-data"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", "/objects-form-data"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", f"/objects-form-data"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def post_multipart_form_data(
        self,
        body: PostFile | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        files: Mapping[str, FileTypes] | Sequence[tuple[str, FileTypes]] | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/multipart-form-data")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostFile):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        # Content-Type=multipart/form-data doesn't work, because header MUST contain boundaries
        # let library do it for us
        headers_.pop("Content-Type", None)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "post",
                url,
                data=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
                files=files,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", "/multipart-form-data"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", f"/multipart-form-data"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", "/multipart-form-data"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", f"/multipart-form-data"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def request_body_anyof(
        self,
        body: Data | PostObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/request-body-anyof")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, Data | PostObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "post",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", "/request-body-anyof"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "post", f"/request-body-anyof"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", "/request-body-anyof"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "post", f"/request-body-anyof"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def patch_object(
        self,
        object_id: str,
        body: PatchObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PatchObjectResp | None:
        url = self._get_url(f"/objects/{object_id}")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PatchObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "patch",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "patch", "/objects/:object_id"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "patch", f"/objects/{object_id}"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "patch", "/objects/:object_id"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "patch", f"/objects/{object_id}"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="patch",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PatchObjectResp.model_validate(response.json())

    async def put_object(
        self,
        object_id: str,
        body: PutObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PutObjectResp | None:
        url = self._get_url(f"/objects/{object_id}")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PutObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "put",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "put", "/objects/:object_id"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "put", f"/objects/{object_id}"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "put", "/objects/:object_id"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "put", f"/objects/{object_id}"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="put",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PutObjectResp.model_validate(response.json())

    async def put_object_slow(
        self,
        object_id: str,
        body: PutObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PutObjectResp | None:
        url = self._get_url(f"/slow/objects/{object_id}")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PutObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "put",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "put", "/slow/objects/:object_id"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "put", f"/slow/objects/{object_id}"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "put", "/slow/objects/:object_id"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "put", f"/slow/objects/{object_id}"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="put",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PutObjectResp.model_validate(response.json())

    async def delete_object(
        self,
        object_id: str,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> DeleteObjectResp | None:
        url = self._get_url(f"/objects/{object_id}")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = await self.client.request(
                "delete",
                url,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "delete", "/objects/:object_id"
                    )
                else:
                    self.metrics_integration.on_request_error(
                        self.client_name, exc, "delete", f"/objects/{object_id}"
                    )
            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "delete", "/objects/:object_id"
                )
            else:
                self.metrics_integration.on_request_success(
                    self.client_name, response, "delete", f"/objects/{object_id}"
                )
        req = RequestBox(
            client_name=self.client_name,
            method="delete",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return DeleteObjectResp.model_validate(response.json())

    async def close(self) -> None:
        await self.client.aclose()

    def _get_url(self, path: str) -> str:
        return f"{self.base_url}{path}"

    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {"extra": {"props": {"data": kwargs}}}

    def log_error(
        self, client_name: str, method, url: str, params, content, headers
    ) -> None:
        msg = f"request error"
        msg += f" | client={client_name}"
        msg += f" | method={method}"
        msg += f" | url={url}"
        msg += f" | params={params}"
        msg += f" | content={content}"
        msg += f" | headers={headers}"

        logging.error(
            msg,
            **self.log_extra(
                client=client_name,
                method=method,
                content=content,
                url=url,
                params=params,
            ),
        )

    def _parse_any_of(self, item: dict[str, Any], schema_classes: list[Any]) -> Any:
        for schema_class in schema_classes:
            try:
                return schema_class.model_validate(item)
            except:
                continue

        raise Exception('Can\'t parse "{item}"')


AllOfRefObj.model_rebuild()
GetBinaryResponse200.model_rebuild()
GetTextAsIntegerResponse200.model_rebuild()
GetTextResponse200.model_rebuild()
GetListObjectsResponse200.model_rebuild()
RewardsListItem.model_rebuild()
GetObjectWithInlineArrayResponse200.model_rebuild()
GetObjectWithInlineArrayResponse200Item.model_rebuild()
TierObj.model_rebuild()
GetObjectNoRefSchemaResponse200.model_rebuild()
SafetyKeyForTesting.model_rebuild()
UnknownError.model_rebuild()
DeleteObjectResp.model_rebuild()
PutObjectResp.model_rebuild()
PatchObjectResp.model_rebuild()
PostObjectResp.model_rebuild()
PostFile.model_rebuild()
PutObjectData.model_rebuild()
PatchObjectData.model_rebuild()
PostObjectData.model_rebuild()
Dog.model_rebuild()
Cat.model_rebuild()
GetObjectResp.model_rebuild()
Data.model_rebuild()
AllOfResp.model_rebuild()
